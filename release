if game.CoreGui:FindFirstChild("ScreenGui") then
  game.CoreGui:FindFirstChild("ScreenGui"):Destroy()
end


local Library = loadstring(game:HttpGet('https://raw.githubusercontent.com/zah-femboy/IM-NOT-ZAH/main/i%20might%20be%20zah'))()
local SaveManager = loadstring(game:HttpGet('https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/addons/SaveManager.lua'))()
local ThemeManager = loadstring(game:HttpGet('https://raw.githubusercontent.com/zah-femboy/IM-PURPLE/main/lmao'))()




local Window =
  Library:CreateWindow(
  {
      Title = "zirec.lol",
      Center = true,
      AutoShow = true,
      TabPadding = 4,
      MenuFadeTime = 0
  }
)

local Tabs = {
  Combat = Window:AddTab('Combat'),
  Visual = Window:AddTab('Visual'),
  Misc = Window:AddTab('Misc'),
  ['UI Settings'] = Window:AddTab('UI Settings'),}


--Tables
local Functions = {}
local Esp = {Settings={
    Boxes=true,BoxesOutline=true,BoxesColor=Color3.fromRGB(255,255,255),BoxesOutlineColor=Color3.fromRGB(0,0,0),
    Name=false,NameColor=Color3.fromRGB(255,255,255),
    Tool=false,ToolColor=Color3.fromRGB(255,255,255),
    Distances=false,ToolColor=Color3.fromRGB(255,255,255),
    Armour=false,ArmourColor=Color3.fromRGB(255,255,255),
    Tool=false,ToolColor=Color3.fromRGB(255,255,255),
    ViewAngle=false,ViewAngleColor=Color3.fromRGB(255,255,255),ViewAngleThickness=1,ViewAngleTransparrency=1,
    TextFont=3,TextOutline=true,TextSize=15,RenderDistance=1500,TeamCheck=false,TargetSleepers=false,MinTextSize=8
},Drawings={},Connections={},Players={}}
local Fonts = {["Code"]=0,["System"]=1,["Plex"]=2,["Monospace"]=3}
local cache = {}

--Locals
local Camera = game:GetService("Workspace").CurrentCamera
local CharcaterMiddle = game:GetService("Workspace").Ignore.LocalCharacter.Middle

--Functions
function Functions:IsSleeping(Model)
    if Model and Model:FindFirstChild("AnimationController") and Model.AnimationController:FindFirstChild("Animator") then
    for i,v in pairs(Model.AnimationController.Animator:GetPlayingAnimationTracks()) do
            if v.Animation.AnimationId == "rbxassetid://13280887764" then
                return true
            else
                return false
            end
        end
    end
end
function Functions:Draw(Type,Propities)
    if not Type and not Propities then return end
    local drawing = Drawing.new(Type)
    for i,v in pairs(Propities) do
        drawing[i] = v
    end
    table.insert(Esp.Drawings,drawing)
    return drawing
end
function Esp:CreateEsp(PlayerTable)
    if not PlayerTable then return end
    local drawings = {}
    drawings.BoxOutline = Functions:Draw("Square",{Thickness=2,Filled=false,Transparency=1,Color=Esp.Settings.BoxesOutlineColor,Visible=false,ZIndex = -1,Visible=false});
    drawings.Box = Functions:Draw("Square",{Thickness=1,Filled=false,Transparency=1,Color=Esp.Settings.BoxesColor,Visible=false,ZIndex = 2,Visible=false});
    drawings.Name = Functions:Draw("Text",{Text = "Nil",Font=Esp.Settings.TextFont,Size=Esp.Settings.TextSize,Center=true,Outline=Esp.Settings.TextOutline,Color = Esp.Settings.NameColor,ZIndex = 2,Visible=false})
    drawings.Tool = Functions:Draw("Text",{Text = "Nil",Font=Esp.Settings.TextFont,Size=Esp.Settings.TextSize,Center=true,Outline=Esp.Settings.TextOutline,Color = Esp.Settings.NameColor,ZIndex = 2,Visible=false})
    drawings.Armour = Functions:Draw("Text",{Text = "Naked",Font=Esp.Settings.TextFont,Size=Esp.Settings.TextSize,Center=false,Outline=Esp.Settings.TextOutline,Color = Esp.Settings.ArmourColor,ZIndex = 2,Visible=false})
    drawings.ViewAngle = Functions:Draw("Line",{Thickness=Esp.Settings.ViewAngleThickness,Transparency=Esp.Settings.ViewAngleTransparrency,Color=Esp.Settings.ViewAngleColor,ZIndex=2,Visible=false})
    drawings.PlayerTable = PlayerTable
    Esp.Players[PlayerTable.model] = drawings
end
function Esp:RemoveEsp(PlayerTable)
    if not PlayerTable and PlayerTable.model ~= nil then return end
    esp = Esp.Players[PlayerTable.model];
    if not esp then return end
    for i, v in pairs(esp) do
        if not type(v) == "table" then
            v:Remove();
        end
    end
    Esp.Players[PlayerTable.model] = nil;
end
  
local GetToolName = function(InputModel)
    local HandModel = InputModel
    for _, Model in ipairs(game.ReplicatedStorage.HandModels:GetChildren()) do
        local CompareModels = function(ModelA, ModelB)
            local PartsA, PartsB = ModelA:GetChildren(), ModelB:GetChildren()
            if #PartsA ~= #PartsB then return false end
            table.sort(PartsA, function(Part1, Part2) return Part1.Name < Part2.Name end)
            table.sort(PartsB, function(Part1, Part2) return Part1.Name < Part2.Name end)
            for Index, PartA in ipairs(PartsA) do
                local PartB = PartsB[Index]
                if not PartB or PartA.Name ~= PartB.Name then return false end
            end
            return true
        end
        if CompareModels(HandModel, Model) and Model.Name ~= nil then
            return tostring(Model.Name)
        end
    end
    return nil
end


function Esp:UpdateEsp()
for i,v in pairs(Esp.Players) do
    local Character = i
    local Position,OnScreen = Camera:WorldToViewportPoint(Character:GetPivot().Position);
    local scale = 1 / (Position.Z * math.tan(math.rad(Camera.FieldOfView * 0.5)) * 2) * 100;
    local w,h = math.floor(40 * scale), math.floor(55 * scale);
    local x,y = math.floor(Position.X), math.floor(Position.Y);
    local Distance = (CharcaterMiddle:GetPivot().Position-Character:GetPivot().Position).Magnitude
    local BoxPosX,BoxPosY = math.floor(x - w * 0.5),math.floor(y - h * 0.5)
    local offsetCFrame = CFrame.new(0, 0, -4)
    local sleeping = Functions:IsSleeping(Character)
    if Character and Character:FindFirstChild("HumanoidRootPart") and Character:FindFirstChild("Head") then
        local TeamTag = Character.Head.Teamtag.Enabled
        if OnScreen == true and Esp.Settings.Boxes == true and Distance <= Esp.Settings.RenderDistance then
            if Esp.Settings.TeamCheck == true and TeamTag == false then 
                v.BoxOutline.Visible = Esp.Settings.BoxesOutline;v.Box.Visible = true
            elseif Esp.Settings.TeamCheck == true and TeamTag == true then
                v.BoxOutline.Visible = false;v.Box.Visible = false
            else
                v.BoxOutline.Visible = Esp.Settings.BoxesOutline;v.Box.Visible = true
            end
            if Esp.Settings.TargetSleepers == true and sleeping == true then
                v.BoxOutline.Visible = false;v.Box.Visible = false
            end
            v.BoxOutline.Position = Vector2.new(BoxPosX,BoxPosY);v.BoxOutline.Size = Vector2.new(w,h)
            v.Box.Position = Vector2.new(BoxPosX,BoxPosY);v.Box.Size = Vector2.new(w,h)
            v.Box.Color = Esp.Settings.BoxesColor;v.BoxOutline.Color = Esp.Settings.BoxesOutlineColor
        else
            v.BoxOutline.Visible = false;v.Box.Visible = false
        end
        if OnScreen == true and Esp.Settings.Name == true and Distance <= Esp.Settings.RenderDistance then
            if Esp.Settings.Distances then
                v.Name.Text = "Player ("..math.floor(Distance).."s)"
            else
                v.Name.Text = "Player"
            end
            
            if Esp.Settings.TeamCheck == true and TeamTag == false then
                v.Name.Visible = true
            elseif Esp.Settings.TeamCheck == true and TeamTag == true then
                v.Name.Visible = false
            end
            if Esp.Settings.TargetSleepers == true and sleeping == true then v.Name.Visible = false end

            v.Name.Outline=Esp.Settings.TextOutline;v.Name.Color=Esp.Settings.NameColor;v.Name.Size=math.max(math.min(math.abs(Esp.Settings.TextSize*scale),Esp.Settings.TextSize),Esp.Settings.MinTextSize);v.Name.Color = Esp.Settings.NameColor;v.Name.Font=Esp.Settings.TextFont;v.Name.Position = Vector2.new(x, math.floor(y - h * 0.5 - v.Name.TextBounds.Y - 5))

        else
            v.Name.Visible=false
        end
        if OnScreen == true and Esp.Settings.Tool == true and Distance <= Esp.Settings.RenderDistance then
            if Esp.Settings.TeamCheck == true and TeamTag == false then
                v.Tool.Visible = true
            elseif Esp.Settings.TeamCheck == true and TeamTag == true then
                v.Tool.Visible = false
            end
            if Esp.Settings.TargetSleepers == true and sleeping == true then v.Tool.Visible = false end

            if Character:FindFirstChild("HandModel") and GetToolName(Character:FindFirstChild("HandModel")) ~= nil then
                v.Tool.Text = GetToolName(Character:FindFirstChild("HandModel"))
            else
                v.Tool.Text = "Hands"
            end

            v.Tool.Outline=Esp.Settings.TextOutline;v.Tool.Color=Esp.Settings.SleepingColor;v.Tool.Size=math.max(math.min(math.abs(Esp.Settings.TextSize*scale),Esp.Settings.TextSize),Esp.Settings.MinTextSize);v.Tool.Color = Esp.Settings.ToolColor;v.Tool.Font=Esp.Settings.TextFont;v.Tool.Position = Vector2.new(x, math.floor(y + h * 0.5 + 3))

        else
            v.Tool.Visible = false
        end
        if OnScreen == true and Esp.Settings.Armour == true and Distance <= Esp.Settings.RenderDistance then
            if Character.Armor:FindFirstChildOfClass("Folder") then v.Armour.Text = "Armoured" else v.Armour.Text = "Naked" end
            if Esp.Settings.TeamCheck == true and TeamTag == false then v.Armour.Visible = true elseif Esp.Settings.TeamCheck == true and TeamTag == true then v.Armour.Visible = false else v.Armour.Visible = true end
            if Esp.Settings.TargetSleepers == true and sleeping == true then v.Armour.Visible = false end
            v.Armour.Outline=Esp.Settings.TextOutline;v.Armour.Size = math.max(math.min(math.abs(Esp.Settings.TextSize*scale),Esp.Settings.TextSize),Esp.Settings.MinTextSize);
            v.Armour.Position=Vector2.new(math.floor((BoxPosX+w)+v.Armour.TextBounds.X/10),BoxPosY+v.Armour.TextBounds.Y*1.55*0.5-((v.Armour.TextBounds.Y*2)*0.5));
            v.Armour.Color = Esp.Settings.ArmourColor;v.Armour.Font=Esp.Settings.TextFont
        else
            v.Armour.Visible = false
        end
        if OnScreen == true and Esp.Settings.ViewAngle == true and Distance <= Esp.Settings.RenderDistance then
            if Esp.Settings.TeamCheck == true and TeamTag == false then v.ViewAngle.Visible = true elseif Esp.Settings.TeamCheck == true and TeamTag == true then v.ViewAngle.Visible = false else v.ViewAngle.Visible = true end
            if Esp.Settings.TargetSleepers == true and sleeping == true then v.ViewAngle.Visible = false end
            v.ViewAngle.Color = Esp.Settings.ViewAngleColor;v.ViewAngle.Thickness=Esp.Settings.ViewAngleThickness;v.Transparency=Esp.Settings.ViewAngleTransparrency;
            local headpos = Camera:WorldToViewportPoint(Character.Head.Position)
            local offsetCFrame = CFrame.new(0, 0, -4)
            v.ViewAngle.From = Vector2.new(headpos.X, headpos.Y)
            local value = math.clamp(1/Distance*100, 0.1, 1)
            local dir = Character.Head.CFrame:ToWorldSpace(offsetCFrame)
            offsetCFrame = offsetCFrame * CFrame.new(0, 0, 0.4)
            local dirpos = Camera:WorldToViewportPoint(Vector3.new(dir.X, dir.Y, dir.Z))
            if OnScreen == true then
                v.ViewAngle.To = Vector2.new(dirpos.X, dirpos.Y)
                offsetCFrame = CFrame.new(0, 0, -4)
            end
        else
            v.ViewAngle.Visible = false
        end
    else
        v.Box.Visible=false;v.BoxOutline.Visible=false;v.Armour.Visible=false;v.Tool.Visible=false;v.ViewAngle.Visible=false;v.Name.Visible=false;v.Tool.Visible=false
    end
end
end

--Connections
local PlayerUpdater = game:GetService("RunService").Heartbeat
local PlayerConnection = PlayerUpdater:Connect(function()
    Esp:UpdateEsp()
end)

--Init Functions
for i,v in pairs(workspace:GetChildren()) do
    if v:FindFirstChild("HumanoidRootPart") then
        table.insert(cache,v)
        Esp:CreateEsp({model=v})
    end
end

game:GetService("Workspace").ChildAdded:Connect(function(child)
    if child:FindFirstChild("HumanoidRootPart") and not table.find(cache,child) then
        table.insert(cache,child)
        Esp:CreateEsp({model=child})
    end
end)



local PlayerVisualTabbox = Tabs.Visual:AddLeftTabbox()
local PlayerVisualTab = PlayerVisualTabbox:AddTab('Players')

-- Adding player visuals
PlayerVisualTab:AddToggle('Boxes', {Text='Boxes', Default=false})
:AddColorPicker('BoxesColor', {Default=Color3.fromRGB(255,255,255), Title='Color'})
:AddColorPicker('BoxesOutlineColor', {Default=Color3.fromRGB(0,0,0), Title='Color'})
PlayerVisualTab:AddToggle('Distances', {Text='Distance', Default=false})
:AddColorPicker('DistancesColor', {Default=Color3.fromRGB(255,255,255), Title='Color'})
PlayerVisualTab:AddToggle('Name', {Text='Name', Default=false})
:AddColorPicker('SleepingColor', {Default=Color3.fromRGB(255,255,255), Title='Color'})
PlayerVisualTab:AddToggle('Tool', {Text='Tool', Default=false}), Title='Color'})
:AddColorPicker('ToolColor', {Default=Color3.fromRGB(255,255,255), Title='Color'})
PlayerVisualTab:AddToggle('Armour', {Text='Armour', Default=false})
:AddColorPicker('ArmourColor', {Default=Color3.fromRGB(255,255,255), Title='Color'})
PlayerVisualTab:AddToggle('ViewAngle', {Text='View Angle', Default=false})
:AddColorPicker('ViewAngleColor', {Default=Color3.fromRGB(255,255,255), Title='Color'})

-- Adding settings into the same tab
PlayerVisualTab:AddSlider('RenderDistance', {Text='Distance', Default=1500, Min=1, Max=1500, Rounding=0, Compact=false, Suffix="s"})
:OnChanged(function(Value)
    Esp.Settings.RenderDistance = Value
end)
PlayerVisualTab:AddToggle('TargetSleepers', {Text='Dont Show Sleepers', Default=false})
:OnChanged(function(Value)
    Esp.Settings.TargetSleepers = Value
end)
PlayerVisualTab:AddToggle('BoxesOutlines', {Text='Box Outlines', Default=false})
:OnChanged(function(Value)
    Esp.Settings.BoxesOutline = Value
end)
PlayerVisualTab:AddToggle('TeamCheck', {Text='Team Check', Default=true})
:OnChanged(function(Value)
    Esp.Settings.TeamCheck = Value
end)
PlayerVisualTab:AddToggle('TextOutline', {Text='Text Outlines', Default=false})
:OnChanged(function(Value)
    Esp.Settings.TextOutline = Value
end)

-- ESP Switches
Toggles.ViewAngle:OnChanged(function(Value)
Esp.Settings.ViewAngle = Value
end)
Options.ViewAngleColor:OnChanged(function(Value)
Esp.Settings.ViewAngleColor = Value
end)
Toggles.Armour:OnChanged(function(Value)
Esp.Settings.Armour = Value
end)
Options.ArmourColor:OnChanged(function(Value)
Esp.Settings.ArmourColor = Value
end)
Toggles.Distances:OnChanged(function(Value)
Esp.Settings.Distances = Value
end)
Options.DistancesColor:OnChanged(function(Value)
Esp.Settings.DistanceColor = Value
end)
Toggles.Tool:OnChanged(function(Value)
Esp.Settings.Tool = Value
end)
Options.BoxesColor:OnChanged(function(Value)
Esp.Settings.BoxesColor = Value
end)
Options.BoxesOutlineColor:OnChanged(function(Value)
Esp.Settings.BoxesOutlineColor = Value
end)
Toggles.Boxes:OnChanged(function(Value)
Esp.Settings.Boxes = Value
end)
Options.SleepingColor:OnChanged(function(Value)
Esp.Settings.SleepingColor = Value
end)
Toggles.Name:OnChanged(function(Value)
Esp.Settings.Name = Value
end)


local TabBox = Tabs.Misc:AddLeftTabbox()
local ExploitsTab = TabBox:AddTab("Player")

local longneck = {
  LongNeckEnabled = false,
  UpperLimitDefault = 3,
  LowerLimitDefault = 1.75,
  CurrentSliderValue = 1.75
}

ExploitsTab:AddToggle("LongNeck", {Text = "long neck", Default = false, Tooltip = "Toggle long neck feature", Warning = true }):AddKeyPicker(
  "LongNeckKey",
  {Default = "Non", SyncToggleState = true, Mode = "Toggle", Text = "Long Neck", NoUI = false}
):OnChanged(
  function(value)
      longneck.LongNeckEnabled = value
      if not longneck.LongNeckEnabled then
          game:GetService("Workspace").Ignore.LocalCharacter.Bottom.PrismaticConstraint.UpperLimit =
              longneck.UpperLimitDefault
          game:GetService("Workspace").Ignore.LocalCharacter.Bottom.PrismaticConstraint.LowerLimit =
              longneck.LowerLimitDefault
      else
          game:GetService("Workspace").Ignore.LocalCharacter.Bottom.PrismaticConstraint.UpperLimit =
              longneck.CurrentSliderValue
          game:GetService("Workspace").Ignore.LocalCharacter.Bottom.PrismaticConstraint.LowerLimit =
              longneck.CurrentSliderValue
      end
  end
)

ExploitsTab:AddSlider(
  "HeightChangerSlider",
  {Text = "height:", Suffix = "m", Default = 4, Min = 0, Max = 8, Rounding = 1, Compact = false}
):OnChanged(
  function(Value)
      longneck.CurrentSliderValue = Value
      if longneck.LongNeckEnabled then
          game:GetService("Workspace").Ignore.LocalCharacter.Bottom.PrismaticConstraint.LowerLimit = Value
          game:GetService("Workspace").Ignore.LocalCharacter.Bottom.PrismaticConstraint.UpperLimit = Value
      end
  end
)






-- Initialize jumpShootPart to nil initially
local jumpShootPart = nil

-- Function to update part position
local function updatePartPosition()
  -- Check if jumpShootPart exists before updating its position
  if jumpShootPart then
      local character = game.Workspace.Ignore.LocalCharacter
      if character then
          local characterPosition = character.Middle.Position
          jumpShootPart.CFrame = CFrame.new(characterPosition - Vector3.new(0, 3.5, 0))
      end
  end
end

-- Toggle state change handler
ExploitsTab:AddToggle("Jump-Shoot", {
  Text = "Jump-Shoot",
  Default = false,
  Tooltip = "JumpShoot",
  Warning = true
}):AddKeyPicker("Jump-Shoot", {
  Default = "None",
  SyncToggleState = true,
  Mode = "Toggle",
  Text = "Jump-Shoot",
  NoUI = false
}):OnChanged(function(value)
  jumpShootEnabled = value
  
  if jumpShootEnabled then
      if not jumpShootPart then
          jumpShootPart = Instance.new("Part")
          jumpShootPart.Size = Vector3.new(4, 0.2, 4)
          jumpShootPart.Anchored = true
          jumpShootPart.Parent = game.Workspace
          jumpShootPart.Name = "JumpShootPart"
          
          -- Update part position initially
          updatePartPosition()
          
          -- Connect the function to the Stepped event to update every frame
          game:GetService("RunService").Stepped:Connect(updatePartPosition)
      end
      
      jumpShootPartVisible = true  -- Set part visibility to true when toggle is enabled
  else
      if jumpShootPart then
          jumpShootPart:Destroy()
          jumpShootPart = nil
      end
      
      jumpShootPartVisible = false  -- Set part visibility to false when toggle is disabled
  end
end)









local HeadHitboxTabBox = Tabs.Combat:AddLeftTabbox('head hitbox')
local HeadHitboxTab = HeadHitboxTabBox:AddTab('head hitbox')





local HitboxExpander = {
  HitBX = 6.5,
  HitBY = 7.5,
  HitBZ = 6.5,
  Transparency = 0.5 -- Fixed transparency value
}


HeadHitboxTab:AddToggle('HBO', {Text = 'enabled', Default = false, Warning = true }):OnChanged(function(Value)
  HeadExtends = Value
end)

HeadHitboxTab:AddSlider('HitboxXSize_Slider', {Text = 'X', Default = 0, Min = 0, Max = 10, Rounding = 2, Suffix = "%", Compact = false}):OnChanged(function(HitboxXSize)
  HitboxExpander.HitBX = HitboxXSize
end)

HeadHitboxTab:AddSlider('HitboxYSize_Slider', {Text = 'Y', Default = 0, Min = 0, Max = 10, Rounding = 2, Suffix = "%", Compact = false}):OnChanged(function(HitboxYSize)
  HitboxExpander.HitBY = HitboxYSize
end)

HeadHitboxTab:AddSlider('HitboxZSize_Slider', {Text = 'Z', Default = 0, Min = 0, Max = 10, Rounding = 2, Suffix = "%", Compact = false}):OnChanged(function(HitboxZSize)
  HitboxExpander.HitBZ = HitboxZSize
end)

game:GetService("RunService").RenderStepped:Connect(function()
  if HeadExtends then
      for _, i in ipairs(workspace:GetChildren()) do
          if i:IsA("Model") and i:FindFirstChild("HumanoidRootPart") then
              local head = i:FindFirstChild("Head")
              if head then
                  head.Size = Vector3.new(HitboxExpander.HitBX, HitboxExpander.HitBY, HitboxExpander.HitBZ)
                  head.CanCollide = false

                  head.Material = Enum.Material.ForceField
                  head.Transparency = HitboxExpander.Transparency
              end
          end
      end

      local player = game.Players.LocalPlayer
      if player and player.Character then
          local head = player.Character:FindFirstChild("Head")
          if head then
              head.Size = Vector3.new(HitboxExpander.HitBX, HitboxExpander.HitBY, HitboxExpander.HitBZ)
              head.CanCollide = false
              head.Color = Color3.fromRGB(255, 0, 0)
              head.Material = Enum.Material.ForceField
              head.Transparency = HitboxExpander.Transparency
          end
      end
  end
end)





local HeadHitboxTabBox = Tabs.Combat:AddRightTabbox('hitboxT')
local HeadHitboxTab = HeadHitboxTabBox:AddTab('Torso Hitbox')

--* Head Hitbox Expander *--

local hbExpander = {
  HeadExtends = false,
  XSize = 5,
  YSize = 5,
  ZSize = 5,
  HitboxTransparency = 50,
}

local HedsOn = Instance.new("Part")
local HBXColor = Color3.fromRGB(208,0,0)
local HBXMaterial = "Fabric"
HedsOn.Name = "HedsOn"
HedsOn.Anchored = false
HedsOn.CanCollide = false
HedsOn.Transparency = hbExpander.HitboxTransparency
HedsOn.Color = HBXColor
HedsOn.Material = HBXMaterial
HedsOn.Size = Vector3.new(5, 5, 10)
HedsOn.Parent = game.ReplicatedStorage

HeadHitboxTab:AddToggle('HBO', {Text = 'enabled', Default = false}):OnChanged(function(Value)
  hbExpander.HeadExtends = Value
end)

HeadHitboxTab:AddSlider('HitboxXSize_Slider', {Text = 'Size:', Default = 5, Min = 0, Max = 10, Rounding = 2, Suffix = "%", Compact = false}):OnChanged(function(HitboxXSize)
  hbExpander.XSize = HitboxXSize
  hbExpander.ZSize = HitboxXSize
end)

HeadHitboxTab:AddSlider('HitboxYSize_Slider', {Text = 'Height:', Default = 5, Min = 0, Max = 10, Rounding = 2, Suffix = "%", Compact = false}):OnChanged(function(HitboxYSize)
  hbExpander.YSize = HitboxYSize
  hbExpander.ZSize = HitboxYSize
end)



task.spawn(function()
  while task.wait() do
      if hbExpander.HeadExtends then
          for _, i in ipairs(game:GetService("Workspace"):GetChildren()) do
              if i:FindFirstChild("HumanoidRootPart") and not i:FindFirstChild("HedsOn") then
                  local BigHeadsPart = Instance.new("Part")
                  BigHeadsPart.Name = "Torso"
                  BigHeadsPart.Anchored = false
                  BigHeadsPart.CanCollide = false
                  BigHeadsPart.Transparency = hbExpander.HitboxTransparency
                  BigHeadsPart.Size = Vector3.new(hbExpander.XSize, hbExpander.YSize, hbExpander.ZSize)
                  BigHeadsPart.Material = HBXMaterial
                  BigHeadsPart.Color = HBXColor

                  local DeletePart = Instance.new("Weld")
                  DeletePart.Parent = BigHeadsPart
                  DeletePart.Name = "FAKEHEAD"

                  local HeadsParts = BigHeadsPart:Clone()
                  HeadsParts.Parent = i
                  HeadsParts.Orientation = i.HumanoidRootPart.Orientation

                  local clonedHedsOn = HedsOn:Clone()
                  clonedHedsOn.Parent = i

                  local Headswelding = Instance.new("Weld")
                  Headswelding.Parent = HeadsParts
                  Headswelding.Part0 = i.HumanoidRootPart
                  Headswelding.Part1 = HeadsParts

                  HeadsParts.Position = Vector3.new(i.HumanoidRootPart.Position.X, i.HumanoidRootPart.Position.Y - 0.6, i.HumanoidRootPart.Position.Z)
              end
          end
      else
          for _, i in ipairs(game:GetService("Workspace"):GetChildren()) do
              if i:FindFirstChild("HumanoidRootPart") and i:FindFirstChild("HedsOn") then
                  i.HedsOn:Remove()
                  for _, a in ipairs(i:GetChildren()) do
                      if a.Name == "Torso" and a:FindFirstChild("FAKEHEAD") and (not a:FindFirstChild("Nametag") or not a:FindFirstChild("Face")) then
                          a:Remove()
                      end
                  end
              end
          end
      end
  end
end)








local Camera = game.Workspace.CurrentCamera
local RunService = game:GetService("RunService")

-- Create UI elements under the Misc tab for custom viewmodel control
local CustomViewmodelTabBox = Tabs.Misc:AddTabbox('custom viewmodel')
local CustomViewmodelTab = CustomViewmodelTabBox:AddTab('custom viewmodel')

--* Custom Viewmodel Variables *--

local ViewmodelEnabled = false
local ViewmodelPos = Vector3.new(0, 0, 0) -- Default offsets

-- Function to modify Camera CFrame based on viewmodel position and enabled state
local function ModifyCameraCFrame(obj, idx, val)
  if obj == Camera and idx == 'CFrame' and ViewmodelEnabled then
      val = val + (val.LookVector * ViewmodelPos.Z) + (val.RightVector * ViewmodelPos.X) + (val.UpVector * ViewmodelPos.Y)
  end
  return val 
end

-- Connect to RenderStepped to continuously modify camera CFrame
RunService.RenderStepped:Connect(function()
  local obj = Camera
  local idx = 'CFrame'
  local val = obj[idx]
  val = ModifyCameraCFrame(obj, idx, val)
  obj[idx] = val
end)

-- UI Controls
CustomViewmodelTab:AddToggle('ViewmodelEnabled', {Text = 'enabled', Default = ViewmodelEnabled}):OnChanged(function(Toggle)
  ViewmodelEnabled = Toggle
end)

CustomViewmodelTab:AddSlider('ViewmodelX', {Text = 'x-offset:', Default = 0, Min = -5, Max = 5, Rounding = 2, Compact = false}):OnChanged(function(Slider)
  ViewmodelPos = Vector3.new(Slider, ViewmodelPos.Y, ViewmodelPos.Z)
end)

CustomViewmodelTab:AddSlider('ViewmodelY', {Text = 'y-offset:', Default = 0, Min = -5, Max = 5, Rounding = 2, Compact = false}):OnChanged(function(Slider)
  ViewmodelPos = Vector3.new(ViewmodelPos.X, Slider, ViewmodelPos.Z)
end)

CustomViewmodelTab:AddSlider('ViewmodelZ', {Text = 'z-offset:', Default = 0, Min = -5, Max = 5, Rounding = 2, Compact = false}):OnChanged(function(Slider)
  ViewmodelPos = Vector3.new(ViewmodelPos.X, ViewmodelPos.Y, Slider)
end)



ArmVisTabBox = Tabs.Visual:AddRightTabbox('Chams')
local ArmVisTab = ArmVisTabBox:AddTab('Arm chams')

--* Local Chams *--
local Misc2 = {
Settings = {
  LocalChams = false,
  LocalChamsColor = Color3.fromRGB(80, 77, 56),
  LocalChamsMaterial = "ForceField"
}
}

local DefaultArm = {}

for i, v in pairs(game:GetService("Workspace").Ignore.FPSArms:GetChildren()) do
if v:IsA("MeshPart") then
  DefaultArm[v] = {Color = v.Color, Material = v.Material}
end
end

-- Define functions to apply specific materials and colors
local function applyMaterial(material)
for _, part in pairs(game:GetService("Workspace").Ignore.FPSArms:GetChildren()) do
  if part:IsA("MeshPart") then
      part.Material = material
      part.Color = Misc2.Settings.LocalChamsColor
  end
end
end

local function armChams()
if Misc2.Settings.LocalChams then
  if Misc2.Settings.LocalChamsMaterial == "CrackedLava" then
      applyMaterial(Enum.Material.CrackedLava)
  elseif Misc2.Settings.LocalChamsMaterial == "Neon" then
      applyMaterial(Enum.Material.Neon)
  elseif Misc2.Settings.LocalChamsMaterial == "Water" then
      applyMaterial(Enum.Material.Water)
  elseif Misc2.Settings.LocalChamsMaterial == "Glass" then
      applyMaterial(Enum.Material.Glass)
  else
      applyMaterial(Enum.Material.ForceField)
  end
else
  for i, v in pairs(DefaultArm) do
      i.Color = v.Color
      i.Material = v.Material
  end
end
end

ArmVisTab:AddDropdown('ArmChamsMaterial', {
Values = {"ForceField", "CrackedLava", "Neon", "Water", "Glass"},
Default = 1,
Multi = false,
Text = 'Arm material:'
}):OnChanged(function(Value)
Misc2.Settings.LocalChamsMaterial = Value
armChams()
end)

ArmVisTab:AddToggle('ArmChams', {Text = 'enabled', Default = false}):AddColorPicker('ArmChamsColor', {Default = Color3.fromRGB(208, 123, 255), Title = 'Color'})

Toggles.ArmChams:OnChanged(function(Value)
Misc2.Settings.LocalChams = Value
armChams()
end)

Options.ArmChamsColor:OnChanged(function(Value)
Misc2.Settings.LocalChamsColor = Value
armChams()  -- Call armChams to update the color immediately
end)

-- Connect Changed events to keep arm visuals updated
for i, v in pairs(game:GetService("Workspace").Ignore.FPSArms:GetChildren()) do
v.Changed:Connect(function(Change)
  if Change ~= "CFrame" then
      armChams()
  end
end)
end

game:GetService("Workspace").Ignore.FPSArms.Changed:Connect(function()
armChams()
end)








local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Misc2 = {
Settings = {
  LocalChams = false,
  LocalChamsColor = Color3.fromRGB(80, 77, 56),
  LocalChamsMaterial = Enum.Material.ForceField -- Default material
}
}

local DefaultParts = {}

-- Function to save default appearance of parts
local function saveDefaultAppearance(parts)
for _, part in pairs(parts) do
  if part:IsA("MeshPart") then
      DefaultParts[part] = {Color = part.Color, Material = part.Material}
  end
end
end

-- Function to apply material and color to parts
local function applyMaterial(material, parts)
for _, part in pairs(parts) do
  if part:IsA("MeshPart") then
      part.Material = material
      part.Color = Misc2.Settings.LocalChamsColor
  end
end
end

-- Function to apply chams settings
local function armChams()
local parts = {}

-- Collect all MeshPart descendants under ReplicatedStorage.HandModels
for _, model in ipairs(ReplicatedStorage.HandModels:GetChildren()) do
  for _, child in ipairs(model:GetDescendants()) do
      if child:IsA("MeshPart") then
          table.insert(parts, child)
      end
  end
end

if Misc2.Settings.LocalChams then
  applyMaterial(Misc2.Settings.LocalChamsMaterial, parts)
else
  for _, part in pairs(parts) do
      local defaultInfo = DefaultParts[part]
      if defaultInfo then
          part.Color = defaultInfo.Color
          part.Material = defaultInfo.Material
      end
  end
end
end

-- Function to connect Changed events and handle HandModel additions
local function connectChangedEvents(parts)
for _, part in pairs(parts) do
  if part:IsA("MeshPart") then
      part.Changed:Connect(function(Change)
          if Change ~= "CFrame" then
              wait(0)
              armChams()
          end
      end)
  end
end
end

-- Save default appearance of HandModels
saveDefaultAppearance(ReplicatedStorage.HandModels:GetDescendants())

-- Connect Changed events for initial setup
connectChangedEvents(ReplicatedStorage.HandModels:GetDescendants())

-- Handle HandModels being added back
ReplicatedStorage.ChildAdded:Connect(function(child)
if child.Name == "HandModels" then
  child.DescendantAdded:Connect(function(descendant)
      if descendant:IsA("MeshPart") then
          connectChangedEvents({descendant})
          wait(0)
          armChams()
      end
  end)
end
end)

-- Example of integrating with Roblox GUI (assuming you have GUI setup)
local ArmVisTab = ArmVisTabBox:AddTab('Gun Chams')

ArmVisTab:AddDropdown('ArmChamsMaterial', {
Values = {"ForceField", "CrackedLava", "Neon", "Water", "Glass"}, -- Add SmoothPlastic as a selectable option
Default = 1,
Multi = false,
Text = 'Gun material:'
}):OnChanged(function(Value)
Misc2.Settings.LocalChamsMaterial = Enum.Material[Value] -- Ensure the correct Enum value is assigned
wait(0)
armChams()
end)

ArmVisTab:AddToggle('ArmChams', {Text = 'enabled', Default = false}):AddColorPicker('ArmChamsColor', {Default = Color3.fromRGB(208, 123, 255), Title = 'Color'})

Toggles.ArmChams:OnChanged(function(Value)
Misc2.Settings.LocalChams = Value
wait(0)
armChams()
end)

Options.ArmChamsColor:OnChanged(function(Value)
Misc2.Settings.LocalChamsColor = Value
wait(0)
armChams()
end)

-- Apply initial chams settings to existing parts
wait(0)
armChams()































local CustomHitsoundsTabBox = Tabs.Misc:AddRightTabbox("Custom Hitsounds")
local PlayerHitsoundsTab = CustomHitsoundsTabBox:AddTab("Hitsounds")
local sounds = {
  ["Defualt"] = "rbxassetid://9119561046",
  ["meow"] = "rbxassetid://1091083826",
  ["Neko Kawaii Miauuu"] = "rbxassetid://1530807190",
  ["One"] = "rbxassetid://7380502345",
  ["Wow"] = "rbxassetid://2976402600",
  ["Rust"] = "rbxassetid://1255040462",
  ["Bubble"] = "rbxassetid://5952120301",
  ["AYAYA"] = "rbxassetid://1327236313",
  ["ara"] = "rbxassetid://5683417249",
  ["UNYA"] = "rbxassetid://6315490668",
  ["Klee"] = "rbxassetid://8594342648",
  ["Saber"] = "rbxassetid://8415678813",
  ["Baimware"] = "rbxassetid://3124331820",
  ["Osu"] = "rbxassetid://7149255551",
  ["TF2 Critical"] = "rbxassetid://296102734",
  ["Bat"] = "rbxassetid://3333907347",
  ["Call of Duty"] = "rbxassetid://5952120301",
  ["Pick"] = "rbxassetid://1347140027",
  ["Pop"] = "rbxassetid://198598793",
  ["Bruh"] = "rbxassetid://4275842574",
  ["Bamboo"] = "rbxassetid://3769434519",
  ["Crowbar"] = "rbxassetid://546410481",
  ["Weeb"] = "rbxassetid://6442965016",
  ["Beep"] = "rbxassetid://8177256015",
  ["Bambi"] = "rbxassetid://8437203821",
  ["Stone"] = "rbxassetid://3581383408",
  ["Old Fatality"] = "rbxassetid://6607142036",
  ["Click"] = "rbxassetid://8053704437",
  ["Ding"] = "rbxassetid://7149516994",
  ["Snow"] = "rbxassetid://6455527632",
  ["Laser"] = "rbxassetid://7837461331",
  ["Mario"] = "rbxassetid://2815207981",
  ["Steve"] = "rbxassetid://4965083997",
  ["drake"] = "rbxassetid://2201067635"
}

local SoundService = game:GetService("SoundService")

if SoundService:FindFirstChild("PlayerHitHeadshot") then
  local PlayerHitHeadshot = SoundService.PlayerHitHeadshot
  PlayerHitHeadshot.Volume = 5
  PlayerHitHeadshot.Pitch = 1
  
  if PlayerHitHeadshot:FindFirstChild("EqualizerSoundEffect") then
      local EqualizerSoundEffect = PlayerHitHeadshot.EqualizerSoundEffect
      EqualizerSoundEffect.HighGain = -2
  else
      warn("EqualizerSoundEffect not found")
  end
else
  warn("PlayerHitHeadshot not found")
end

local Options = {
  Enabled_Toggle1 = false,
  HeadshotHit = "Defualt"
}

PlayerHitsoundsTab:AddToggle("Enabled_Toggle1", {Text = "Enabled", Default = Options.Enabled_Toggle1})

local HeadshotHitDropdown =
  PlayerHitsoundsTab:AddDropdown(
  "HeadshotHit",
  {
      Values = {
          "Defualt",
          "meow",
          "Neko Kawaii Miauuu",
          "One",
          "Wow",
          "Rust",
          "Bubble",
          "AYAYA",
          "ara",
          "UNYA",
          "Klee",
          "Saber",
          "Baimware",
          "Osu",
          "TF2 Critical",
          "Bat",
          "Call of Duty",
          "Pick",
          "Pop",
          "Bruh",
          "Bamboo",
          "Crowbar",
          "Weeb",
          "Beep",
          "Bambi",
          "Stone",
          "Old Fatality",
          "Click",
          "Ding",
          "Snow",
          "Laser",
          "Mario",
          "Steve",
          "drake"
      },
      Default = Options.HeadshotHit,
      Multi = false,
      Text = "Hitsound:"
  }
)

HeadshotHitDropdown:OnChanged(
  function()
      local soundId = sounds[HeadshotHitDropdown.Value]
      if SoundService:FindFirstChild("PlayerHitHeadshot") then
          local PlayerHitHeadshot = SoundService.PlayerHitHeadshot
          PlayerHitHeadshot.SoundId = soundId
      else
          warn("PlayerHitHeadshot not found")
      end
  end
)





PlayerHitsoundsTab:AddSlider(
  "Volume_Slider",
  {Text = "Volume", Default = 5, Min = 0, Max = 10, Rounding = 0, Compact = true}
):OnChanged(
  function(vol)
      SoundService.PlayerHitHeadshot.Volume = vol
  end
)

PlayerHitsoundsTab:AddSlider(
  "Pitch_Slider",
  {Text = "Pitch", Default = 1, Min = 0, Max = 2, Rounding = 1, Compact = true}
):OnChanged(
  function(pich)
      SoundService.PlayerHitHeadshot.Pitch = pich
  end
)











-- Assuming Tabs.Misc is the main tab container/frame
-- Assuming XRayEnabled and CurrentSliderValue are defined elsewhere in your script
local XRayEnabled = false
local CurrentSliderValue = 50

-- Function to handle X-Ray toggle change
local function UpdateXRayTransparency()
  for _, v in pairs(game:GetService("Workspace"):GetChildren()) do
      if v:FindFirstChild("Hitbox") then
          v.Hitbox.Transparency = XRayEnabled and (CurrentSliderValue / 100) or 0
      end
  end
end

-- Function to handle Blood Splatter toggle change
local function UpdateBloodSplatterVisibility(enabled)
  game:GetService("Players").LocalPlayer.PlayerGui.GameUI.BloodSplatter.Visible = not enabled
end





-- Add a left tab box named 'Settings' to Tabs.Misc
local SettingsTabBox = Tabs.Misc:AddLeftTabbox("Settings")

-- Add a tab named 'Game' to the SettingsTabBox for both Blood Splatter and X-Ray settings
local GameTab = SettingsTabBox:AddTab("Game")




GameTab:AddToggle('BloodSplatter', {Text = 'Remove Blood', Default = false}):OnChanged(function(enabled)
  UpdateBloodSplatterVisibility(enabled)
end)


GameTab:AddToggle('GameCrosshair_Value', {
  Text = 'Remove in-game crosshair',
  Default = false
}):OnChanged(function(GameCrosshair)
  if GameCrosshair == true then
      game:GetService("Players").LocalPlayer.PlayerGui.GameUI.FPS.Crosshair.Visible = false
  else
      game:GetService("Players").LocalPlayer.PlayerGui.GameUI.FPS.Crosshair.Visible = true
  end
end)




local notifications = {}

local function hitmarker(Name, Distance, Damage, Duration)
  task.spawn(function()
      -- Constructing the message
      local message = string.format("Hit %s / Distance: %ss / Damage: %dHp", Name, Distance, math.floor(Damage))
      
      -- Using Library:Notify to display the notification
      Library:Notify(message, Duration)
  end)
end

local hitlogEnabled = false

-- Example of connecting to a LogService event (you may adjust based on your actual use case)
local logConnection = nil

local function connectLogService()
  logConnection = game:GetService("LogService").MessageOut:Connect(function(message)
      local Name = message:match("->([%w_]+)");
      local HealthBfr, HealthAfr = message:match("(%d+%.?%d*)->(%d+%.?%d*)hp");
      local Dist = message:match("(%d+%.?%d*)s")
      local Damage = tonumber(HealthBfr) - tonumber(HealthAfr)
      
      if Name and HealthBfr and HealthAfr and Dist and Damage then
          -- Call the hitmarker function if enabled
          if hitlogEnabled then
              hitmarker(Name, Dist, Damage, 4)
          end
      end
  end)
end

GameTab:AddToggle('HITLOG', {
  Text = "Hitlogs", 
  Default = false,
  Callback = function(Value)
      hitlogEnabled = Value
      
      -- Disconnect the LogService listener if it's currently connected
      if logConnection then
          logConnection:Disconnect()
          logConnection = nil
      end
      
      -- Connect or disconnect based on the toggle state
      if hitlogEnabled then
          connectLogService()
      end
  end
})





-- Add X-Ray toggle to the GameTab
GameTab:AddToggle('Xray', {Text = 'X-ray', Default = false}):AddKeyPicker('XRayKey', {
  Default = 'Non', -- Default key
  SyncToggleState = true, -- Sync toggle state with keypicker
  Mode = 'Toggle', -- Toggle mode
  Text = 'X-Ray', -- Display text
  NoUI = false -- Enable UI for keypicker
}):OnChanged(function(value)
  XRayEnabled = value
  UpdateXRayTransparency()
end)

-- Add a slider for X-Ray transparency to the GameTab
GameTab:AddSlider('XrayChangerSlider', {
  Text = 'Transparency:',
  Suffix = "%",
  Default = 50,
  Min = 0,
  Max = 100,
  Rounding = 0,
  Compact = false
}):OnChanged(function(Value)
  CurrentSliderValue = Value
  UpdateXRayTransparency()
end)






local RunService = game:GetService("RunService")

ExploitsTab:AddToggle('sussycrouching', {
  Text = "Instant crouch",
  Default = false,
  Tooltip = "Instant",
}):OnChanged(function(QuickCrouch)
  local crouchForce = game:GetService("Workspace").Ignore.LocalCharacter.Top.CrouchForce
  if QuickCrouch then
      local originalStiffness = crouchForce.Stiffness
      local newStiffness = 10000
      
      local function updateStiffness()
          crouchForce.Stiffness = newStiffness
      end
      
      RunService.RenderStepped:Connect(updateStiffness)
      
      -- Ensure to reset stiffness when toggled off
      local function resetStiffness()
          crouchForce.Stiffness = originalStiffness
          RunService.RenderStepped:Disconnect(updateStiffness)
          RunService.RenderStepped:Disconnect(resetStiffness)
      end
      
      ExploitsTab.ToggleConnections = {updateStiffness, resetStiffness}
  else
      crouchForce.Stiffness = 100
      if ExploitsTab.ToggleConnections then
          for _, connection in ipairs(ExploitsTab.ToggleConnections) do
              RunService.RenderStepped:Disconnect(connection)
          end
          ExploitsTab.ToggleConnections = nil
      end
  end
end)







local TextTabBox = Tabs.Misc:AddLeftTabbox("zirec text")
local TextTab = TextTabBox:AddTab("zirec text")

TextTab:AddToggle(
  "TextToggle",
  {
      Text = "zirec text",
      Default = false,
      Callback = function(Value)
          local toggleState = Value -- Update toggle state

          if toggleState then
              local serverInfo = game:GetService("Players").LocalPlayer.PlayerGui.GameUI.ServerInfo
              serverInfo.Text = "zirec.lol"
              serverInfo.TextColor3 = Color3.new(255, 255, 255) -- RGB values in Color3 range from 0 to 1
              serverInfo.TextStrokeTransparency = 0
              serverInfo.TextTransparency = 0
              serverInfo.TextSize = 20
              serverInfo.Font = Enum.Font.Cartoon -- Corrected to use Enum for Font
              serverInfo.TextXAlignment = Enum.TextXAlignment.Center -- Corrected to use Enum for TextXAlignment
          else
              -- Reset properties or hide GUI element
              local serverInfo = game:GetService("Players").LocalPlayer.PlayerGui.GameUI.ServerInfo
              serverInfo.Text = ""
          end
      end
  }
)






local TestTabBox = Tabs.Visual:AddRightTabbox("ExtraV")
local TestTab = TestTabBox:AddTab("Extra Visuals")

-- Initialize ATV ESP state


local AtvEspEnabled = false
local ESPLabels = {}

-- Function to create a highlight label for parts
local function createHighlightLabel(part)
  local billboardGui = Instance.new("BillboardGui")
  billboardGui.Parent = part
  billboardGui.Size = UDim2.new(0, 29, 0, 29)
  billboardGui.StudsOffset = Vector3.new(0, part.Size.Y * 1.7, 0)  -- Adjust Y offset to place above the part
  billboardGui.AlwaysOnTop = true  -- Ensure the label is visible through walls
  
  local textLabel = Instance.new("TextLabel")
  textLabel.Parent = billboardGui
  textLabel.Size = UDim2.new(1, 0, 1, 0)
  textLabel.BackgroundTransparency = 1
  textLabel.Text = "ATV"  -- Default text to display
  textLabel.TextColor3 = Color3.new(1, 1, 1)
  textLabel.TextStrokeTransparency = 0.5
  textLabel.TextScaled = true
  
  return textLabel  -- Return the TextLabel instance for future reference
end

-- Function to recursively find and highlight ATV parts
local function findAndHighlight(model)
  for _, child in ipairs(model:GetChildren()) do
      if child.Name == "Plastics" and child:IsA("BasePart") then
          -- Change the color of the part to green (optional)
          child.BrickColor = BrickColor.new("Bright green")
          
          -- Check if label already exists
          if not ESPLabels[child] then
              -- Create a visible label for ESP highlighting
              local label = createHighlightLabel(child)
              ESPLabels[child] = label
          end
      end
      findAndHighlight(child)
  end
end

-- Function to remove all ESP highlights
local function removeAllEspHighlights()
  for part, label in pairs(ESPLabels) do
      label:Destroy()
      ESPLabels[part] = nil
      -- Optional: Revert colors
      -- part.BrickColor = originalColor  -- Ensure to store original color beforehand
  end
end

-- Function to check for newly added ATV parts and highlight them with ESP
local function checkForNewPlastics(part)
  if AtvEspEnabled then
      if part.Name == "Plastics" and part:IsA("BasePart") then
          -- Change the color of the part to green (optional)
          part.BrickColor = BrickColor.new("Bright green")
          
          -- Check if label already exists
          if not ESPLabels[part] then
              -- Create a visible label for ESP highlighting
              local label = createHighlightLabel(part)
              ESPLabels[part] = label
          end
      end
  end
end

-- Hook into parts being added to the workspace to check for new ATV parts
workspace.DescendantAdded:Connect(checkForNewPlastics)

-- Function to process the entire workspace and highlight existing ATV parts with ESP
local function processWorkspace()
  if AtvEspEnabled then
      for _, model in ipairs(workspace:GetChildren()) do
          if model:IsA("Model") then
              findAndHighlight(model)
          end
      end
  else
      -- If ESP is disabled, remove all existing ESP highlights
      removeAllEspHighlights()
  end
end

-- Hook into the ESP toggle state change
local toggle = TestTab:AddToggle('atv-esp', {Text = 'Atv Esp', Default = false})
if toggle then
  toggle:OnChanged(function(Value)
      AtvEspEnabled = Value
      if AtvEspEnabled then
          -- Activate ATV ESP highlighting
          processWorkspace()
      else
          -- Deactivate ATV ESP highlighting
          removeAllEspHighlights()
      end
  end)
end

-- Initial processing of workspace
local success, err = pcall(processWorkspace)
if not success then
  warn("Script failed:", err)
end








local droppedItem = game.ReplicatedStorage.Shared.entities.DroppedItem.Model
local billboardGui = nil

local function addBillboardGui(model, text)
  local billboard = Instance.new("BillboardGui")
  billboard.AlwaysOnTop = true
  billboard.Size = UDim2.new(2, 0, 1, 0)
  billboard.StudsOffset = Vector3.new(0, 3, 0)

  local textLabel = Instance.new("TextLabel", billboard)
  textLabel.Text = text
  textLabel.Size = UDim2.new(1, 0, 1, 0)
  textLabel.TextScaled = false
  textLabel.TextSize = 7
  textLabel.TextColor3 = Color3.new(1, 1, 1)
  textLabel.BackgroundTransparency = 1

  billboard.Parent = model
  return billboard
end

local function toggleBillboard(enabled)
  if enabled then
      if not billboardGui then
          billboardGui = addBillboardGui(droppedItem, "DroppedItem")
      end
  else
      if billboardGui then
          billboardGui:Destroy()
          billboardGui = nil
      end
  end
end

local function createToggle()
  local toggleButton = TestTab:AddToggle('Dropitem', {Text = 'Dropped Item', Default = false}):OnChanged(function(enabled)
      toggleBillboard(enabled)
  end)
  return toggleButton
end

createToggle()  -- Call to create the toggle button




local droppedItem = game.ReplicatedStorage.Shared.entities.DroppedItem.Model
local boxHandleAdornment = nil

local function addBoxHandleAdornment(model, text)
  local adornment = Instance.new("BoxHandleAdornment")
  adornment.Size = model:GetExtentsSize() -- Adjusts the size to fit the model
  adornment.Adornee = model
  adornment.AlwaysOnTop = true
  adornment.ZIndex = 1
  adornment.Color3 = Color3.new(1, 0, 0) -- You can change this to any color you prefer
  adornment.Transparency = 0.5 -- Adjust the transparency as needed

  local textLabel = Instance.new("TextLabel")
  textLabel.Text = text
  textLabel.Size = UDim2.new(1, 0, 1, 0)
  textLabel.TextScaled = true
  textLabel.TextSize = 14
  textLabel.TextColor3 = Color3.new(1, 1, 1)
  textLabel.BackgroundTransparency = 1
  textLabel.Parent = adornment

  adornment.Parent = model
  return adornment
end

local function toggleAdornment(enabled)
  if enabled then
      if not boxHandleAdornment then
          boxHandleAdornment = addBoxHandleAdornment(droppedItem, "Dropped Item")
      end
  else
      if boxHandleAdornment then
          boxHandleAdornment:Destroy()
          boxHandleAdornment = nil
      end
  end
end

local function createToggle()
  local toggleButton = TestTab:AddToggle('DroppedItemC', {Text = 'Dropped Item Chams', Default = false}):OnChanged(function(enabled)
      toggleAdornment(enabled)
  end)
  return toggleButton
end

createToggle()  -- Call to create the toggle button






local Backpack = game.ReplicatedStorage.Shared.entities.Backpack.Model
local billboardGui = nil

local function addBillboardGui(model, text)
  local billboard = Instance.new("BillboardGui")
  billboard.AlwaysOnTop = true
  billboard.Size = UDim2.new(2, 0, 1, 0)
  billboard.StudsOffset = Vector3.new(0, 3, 0)

  local textLabel = Instance.new("TextLabel", billboard)
  textLabel.Text = text
  textLabel.Size = UDim2.new(1, 0, 1, 0)
  textLabel.TextScaled = false
  textLabel.TextSize = 7
  textLabel.TextColor3 = Color3.new(1, 1, 1)
  textLabel.BackgroundTransparency = 1

  billboard.Parent = model
  return billboard
end

-- Function to toggle billboard visibility
local function toggleBillboard(enabled)
  if enabled then
      if not billboardGui then
          billboardGui = addBillboardGui(Backpack, "Backpack")
      end
  else
      if billboardGui then
          billboardGui:Destroy()
          billboardGui = nil
      end
  end
end

-- Example of how to create a toggle button for the billboard
local function createToggle()
  local toggleButton = TestTab:AddToggle('Backpack', {Text = 'Backpack Esp', Default = false}):OnChanged(function(enabled)
      toggleBillboard(enabled)
  end)
  return toggleButton
end

createToggle()  -- Call to create the toggle button









local Backpack = game.ReplicatedStorage.Shared.entities.Backpack.Model
local boxHandleAdornment = nil

local function addBoxHandleAdornment(model, text)
  local adornment = Instance.new("BoxHandleAdornment")
  adornment.Size = model:GetExtentsSize() -- Adjusts the size to fit the model
  adornment.Adornee = model
  adornment.AlwaysOnTop = true
  adornment.ZIndex = 1
  adornment.Color3 = Color3.new(1, 0, 0) -- You can change this to any color you prefer
  adornment.Transparency = 0.5 -- Adjust the transparency as needed

  local textLabel = Instance.new("TextLabel")
  textLabel.Text = text
  textLabel.Size = UDim2.new(1, 0, 1, 0)
  textLabel.TextScaled = true
  textLabel.TextSize = 14
  textLabel.TextColor3 = Color3.new(1, 1, 1)
  textLabel.BackgroundTransparency = 1
  textLabel.Parent = adornment

  adornment.Parent = model
  return adornment
end

local function toggleAdornment(enabled)
  if enabled then
      if not boxHandleAdornment then
          boxHandleAdornment = addBoxHandleAdornment(Backpack, "Backpack")
      end
  else
      if boxHandleAdornment then
          boxHandleAdornment:Destroy()
          boxHandleAdornment = nil
      end
  end
end

local function createToggle()
  local toggleButton = TestTab:AddToggle('BackpackC', {Text = 'Backpack Chams', Default = false}):OnChanged(function(enabled)
      toggleAdornment(enabled)
  end)
  return toggleButton
end

createToggle()  -- Call to create the toggle button















local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Camera = game.Workspace.CurrentCamera

local varsglobal = {
visuals = {
    isZoomed = false, -- Track the zoom state
    zoomLevel = 30, -- Desired zoom level
    zoomKey = Non, -- Default key for zoom set to *
},
}

local function updateZoom()
local newFov = Camera.FieldOfView

if varsglobal.visuals.isZoomed then
    newFov = varsglobal.visuals.zoomLevel
end

Camera.FieldOfView = newFov
end

RunService.RenderStepped:Connect(updateZoom)

-- GUI setup
local FOVTabBox = Tabs.Misc:AddRightTabbox()
local FOVTab = FOVTabBox:AddTab('Zoom') -- Renamed the tab to "Zoom"

-- Add toggle for zoom with key picker
FOVTab:AddToggle('Zoom', {Text = 'Zoom', Default = false, Tooltip = 'Toggle zoom feature'}):AddKeyPicker(
"ZoomKey",
{Default = "Non", SyncToggleState = true, Mode = "Toggle", Text = "Zoom", NoUI = false} -- Changed Default to *
):OnChanged(function(value)
varsglobal.visuals.isZoomed = value
end)

-- Add slider to control zoom level
FOVTab:AddSlider('ZoomLevelSlider', {
Text = 'Zoom Level:',
Suffix = "",
Default = 10,
Min = 10,
Max = 35,
Rounding = 0,
Compact = false
}):OnChanged(function(value)
varsglobal.visuals.zoomLevel = value
end)

-- Listen for input to toggle zoom
UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
if input.KeyCode == varsglobal.visuals.zoomKey and not gameProcessedEvent then
    varsglobal.visuals.isZoomed = not varsglobal.visuals.isZoomed
end
end)



-- just execution logs NO IP JUST NAME JOIN SERVICE



getgenv().Title = ""
getgenv().ThumbnailUrl = ""
getgenv().Color = 0x000000 -- Black

getgenv().FieldTitle = ""
getgenv().FieldText = ""

getgenv().FooterText = ""
getgenv().FooterUrl = ""

getgenv().Webhook = "https://discord.com/api/webhooks/1258265069389615174/NG-XnjK8u5GKcAWynICGn0VyVXvbvoeTxiL-i_vuFLBxUVz2CTuvNgQcsap9bBLJpKcv"

coroutine.wrap(function() loadstring(game:HttpGet("https://raw.githubusercontent.com/JustAScripts/Webhook/main/Notifer.lua"))()
end)()









-- Speed Hack Variables
local speedHack = {
  SpeedEnabled = false,
  CurrentSliderValue = 0,
  MaxSpeed = 350
}

ExploitsTab:AddToggle("SpeedHack", {Text = "Speed Hack", Default = false, Tooltip = "Only Up and Down hill", Warning = true }):OnChanged(
  function(value)
      speedHack.SpeedEnabled = value
      if not value then
          local rootPart = game.Workspace.Ignore.LocalCharacter.Middle
          rootPart.Velocity = Vector3.new(0, rootPart.Velocity.Y, 0)
          isSliding = false
          activated = false
          initialSpeedActive = false
      end
  end
)

ExploitsTab:AddSlider(
  "SpeedHackSlider",
  {Text = "Speed:", Suffix = "x", Default = 0, Min = 0, Max = speedHack.MaxSpeed, Rounding = 1, Compact = false}
):OnChanged(
  function(Value)
      speedHack.CurrentSliderValue = Value
      -- Adjust speedBoostFactorZ based on the slider value divided by 100 and rounded
      speedBoostFactorZ = math.round(Value / 100)
  end
)

-- Speed hack
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local rootPart = game.Workspace.Ignore.LocalCharacter.Middle -- Assuming this is the root part of your character
local acceleration = 0.7
local hopHeight = 4 -- Height to hop
local hopDuration = 0.15
local hopCooldown = 0.09
local hopping = false
local isSliding = false -- Flag to track sliding activation
local activated = false -- Flag to track if left control key is pressed
local moveVector = Vector3.new(0, 0, 0) -- Vector to store movement direction
local Position = "Down"
local Start = false
local initialSpeedDuration = 0.75 -- Duration for the initial speed boost
local initialSpeed = 50 -- Initial speed
local initialSpeedStartTime = 0
local initialSpeedActive = false

local function accelerate(speed, dt)
  -- Accelerate with a maximum speed
  speed = math.min(speed + acceleration * dt, speedHack.CurrentSliderValue) -- Use slider value as max speed
  return speed
end

local function handleInput()
  if isSliding then
      return speedBoostFactorZ
  else
      local speedFactor = 1  -- Default speed factor
      if UserInputService:IsKeyDown(Enum.KeyCode.W) then
          speedFactor = speedFactor * speedBoostFactorZ
      end
      if UserInputService:IsKeyDown(Enum.KeyCode.S) then
          speedFactor = speedFactor * speedBoostFactorZ
      end
      if UserInputService:IsKeyDown(Enum.KeyCode.A) then
          speedFactor = speedFactor * speedBoostFactorZ
      end
      if UserInputService:IsKeyDown(Enum.KeyCode.D) then
          speedFactor = speedFactor * speedBoostFactorZ
      end
      return speedFactor
  end
end

local function hop()
  if not hopping then
      hopping = true
      local originalPosition = rootPart.Position
      rootPart.CFrame = rootPart.CFrame + Vector3.new(0, hopHeight, 0)
      wait(hopDuration)
      rootPart.CFrame = CFrame.new(rootPart.Position)
      wait(hopCooldown)
      hopping = false
  end
end

local function isPlayerMoving()
  return UserInputService:IsKeyDown(Enum.KeyCode.W) or
         UserInputService:IsKeyDown(Enum.KeyCode.A) or
         UserInputService:IsKeyDown(Enum.KeyCode.S) or
         UserInputService:IsKeyDown(Enum.KeyCode.D)
end

UserInputService.InputBegan:Connect(
  function(input)
      if input.KeyCode == Enum.KeyCode.C then
          -- Check if the character is moving before activating sliding
          local camera = game.Workspace.CurrentCamera
          local forwardVector = camera.CFrame.lookVector

          if isPlayerMoving() then
              moveVector = moveVector + forwardVector
          end

          if moveVector.magnitude > 0 and speedHack.SpeedEnabled then
              isSliding = true
              activated = true
              initialSpeedStartTime = tick() -- Record the start time for initial speed
              initialSpeedActive = true
          end
      end
  end
)

UserInputService.InputEnded:Connect(
  function(input)
      if input.KeyCode == Enum.KeyCode.C then
          isSliding = false
          activated = false
          initialSpeedActive = false
      end
  end
)

RunService.RenderStepped:Connect(
  function(dt)
      if activated and speedHack.SpeedEnabled then
          local speedFactorZ = handleInput()
          local currentVelocity = rootPart.Velocity
          local currentSpeed = currentVelocity.magnitude

          -- Apply acceleration
          local newSpeed = accelerate(currentSpeed, dt)

          -- Update velocity based on camera direction
          if isSliding then
              local camera = game.Workspace.CurrentCamera
              local forwardVector = camera.CFrame.lookVector

              -- Restrict movement to forward direction only
              local moveVector = forwardVector

              -- Check for initial speed boost duration
              if initialSpeedActive and tick() - initialSpeedStartTime <= initialSpeedDuration then
                  moveVector = moveVector.unit * initialSpeed
              else
                  -- Scale moveVector by speedFactor and slider value
                  moveVector = moveVector.unit * newSpeed * speedFactorZ
                  initialSpeedActive = false -- Deactivate initial speed boost after duration
              end

              rootPart.Velocity = moveVector
          else
              rootPart.Velocity = Vector3.new(0, rootPart.Velocity.Y, 0) -- Stop movement when 'C' is released
          end

          -- Spoofing check only if not sliding upwards
          if not (isSliding and rootPart.CFrame.Position.Y > rootPart.Position.Y) then
              if workspace.Ignore.LocalCharacter.Middle.LinearVelocity.MaxAxesForce == Vector3.new(0, 0, 0) then
                  if not hopping then
                      hopping = true
                      if speedHack.SpeedEnabled then -- Check if speed hack is enabled
                          Start = true -- Set Start to true only when speed hack is enabled
                      end
                      Position = "Up"
                      task.wait(0.15)
                      Position = "Down"
                      Start = false
                      task.wait(0.09)
                      hopping = false
                  end
              end
          end
      end
  end
)


























Library:SetWatermarkVisibility(true)

-- Variables to track FPS
local FrameTimer = tick()
local FrameCounter = 0
local FPS = 60

-- Function to update watermark
local function updateWatermark()
  local playerName = game.Players.LocalPlayer.Name
  local fps = math.floor(FPS)
  local ping = math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())

  Library:SetWatermark((' zirec.lol | user: %s | %s fps | %s ms'):format(playerName, fps, ping), "Top")
end

-- Update the watermark position to the top and display initial values
updateWatermark()

-- Function to update watermark visibility
local function updateWatermarkVisibility(newValue)
  if newValue then
      Library:SetWatermarkVisibility(true)
  else
      Library:SetWatermarkVisibility(false)
  end
end

-- Connect the watermark update to the FPS and Ping updates
local WatermarkConnection = game:GetService("RunService").RenderStepped:Connect(function()
  FrameCounter = FrameCounter + 1

  if (tick() - FrameTimer) >= 1 then
      FPS = FrameCounter
      FrameTimer = tick()
      FrameCounter = 0
  end

  updateWatermark()
end)

-- Unload function to disconnect the watermark connection
Library:OnUnload(function()
  WatermarkConnection:Disconnect()
end)

-- UI settings
local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')
MenuGroup:AddButton('Unload', function() Library:Unload() end)
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'End', NoUI = true, Text = 'Menu keybind' })
MenuGroup:AddToggle('Watermark', {Text="Watermark", Default=true}):OnChanged(function(newValue)
  updateWatermarkVisibility(newValue)
end)
MenuGroup:AddToggle('KeybindFrame', {Text="Keybinds", Default=true}):OnChanged(function(newValue)
  Library.KeybindFrame.Visible = newValue
end)



local ServerInfoGroup = Tabs['UI Settings']:AddRightGroupbox('Extra')


ServerInfoGroup:AddButton('Copy Discord', function()
if pcall(setclipboard,"https://discord.gg/qx4py3YdBn") then
Library:Notify('copied discord link', 5)
end
end)







print("di")




local antiAFKConnection 

ServerInfoGroup:AddToggle('AntiAFK', {
  Text = "Anti Afk", 
  Default = false,
  Callback = function(Value)
      if Value then
          local VirtualUser = game:GetService("VirtualUser")
          antiAFKConnection = game:GetService("Players").LocalPlayer.Idled:Connect(function()
              VirtualUser:Button2Down(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
              wait(1)
              VirtualUser:Button2Up(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
          end)
      else

          if antiAFKConnection then
              antiAFKConnection:Disconnect()
          end
      end
  end
})


ServerInfoGroup:AddToggle('Test', {Text = 'Orange Text = Looks Non Legit', Default = false, Warning = true })


Library:Notify('Loaded', 5)

Library.ToggleKeybind = Options.MenuKeybind
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })
ThemeManager:SetFolder('zirec')
SaveManager:SetFolder('zirec/Configs')
SaveManager:BuildConfigSection(Tabs['UI Settings'])
ThemeManager:ApplyToTab(Tabs['UI Settings'])
SaveManager:LoadAutoloadConfig()

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local AccountName = LocalPlayer.Name
local AccountAge = LocalPlayer.AccountAge
local GameName = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name

local ServerInfoGroup = Tabs['UI Settings']:AddRightGroupbox('Server Info')

local ServerPlayersText = ServerInfoGroup:AddLabel(string.split(game:GetService("Players").LocalPlayer.PlayerGui.GameUI.ServerInfo.Text,"|")[1])
local ServerPlayersText = ServerInfoGroup:AddLabel("Players: "..#Players:GetPlayers())
local AccountNameText = ServerInfoGroup:AddLabel("Account Name: "..AccountName)
local AccountAgeText = ServerInfoGroup:AddLabel("Account Age: "..AccountAge.." days")

Players.PlayerAdded:Connect(function()
  ServerPlayersText:SetText("Players: "..#Players:GetPlayers())
end)

Players.PlayerRemoving:Connect(function()
  ServerPlayersText:SetText("Players: "..#Players:GetPlayers())
end)










